- 명시적이나 암묵적 둘 다 기존 원시 값을 직접 변경하는 것은 아니다. **타입 변환**이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.
- (원시값: 객체가 아니면서 메서드도 가지지 않는 데이터-불변)
- 본인이 작성한 코드에서 암묵적 타입 변환이 발생하는지, 어떻게 평가될 것인지 예측 가능해야 한다.

### 암묵적 타입 변환
- 가독성 측면에서 명시적 타입 변환보다 좋다.
- **문자열 타입으로 변환**
    - 피연산자만이 암묵적 타입 변환의 대상이 되는 것은 아니다. (ex. 템플릿 리터럴 표현식)
    - symbol 타입은 string으로 타입 변환이 되지 않는다. (TypeError: cannot convert a symbol~ error 뜸)
- **숫자 타입으로 변환**
    - 산술 연산자, 비교 연산자, 단항 연산자의 모든 피연산자의 코드는 문맥상 숫자 타입이어야 함으로 타입 변환이 일어난다.
    - 숫자로 표현될 수 없는 표현식은 NaN이 반환된다.
    - 마찬가지로 symbol 타입은 (TypeError: canot convert a symbol value to a number) 에러가 난다.
    - ‘’(빈 문자열), [](빈 배열), null, false는 0으로, true는 1로 변환되고 객체, 빈 배열이 아닌 배열, undefined는 NaN이 반환된다.
- boolean 타입으로 변환
    - 조건식의 평가 결과를 boolean 타입으로 변환한다. (truthy는 true로, falsy는 false로)
    - **Truthy**
        - falsy가 아닌 모든 값 (’0’, ‘false’는 truthy이다. ) (빈 배열, 빈 객체도 truthy이다. )
    - **Falsy**
        - false, undefined, null, 0, -0, NaN, ‘’

### 명시적 타입 변환
- [https://velog.io/@gusdh2/함수Function와-메서드Method-차이점이-뭘까](https://velog.io/@gusdh2/%ED%95%A8%EC%88%98Function%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9CMethod-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%B4-%EB%AD%98%EA%B9%8C) (함수를 호출하는 객체가 있는 경우 메서드, 함수를 호출하는 객체가 없는 경우 함수)
- **문자열 타입으로**
    - String 생성자 함수 사용 (new 없이, new 사용하면 객체로 나옴)
    - ().toString(); 메서드 사용 (object.prototype.toString)
    - 문자열 연결 연산자 이용 (ex. 5+’’;)
- **숫자 타입으로**
    - Number 생성자 함수 사용
    - ParseInt 혹은 ParseFloat 함수 사용
    - + 단항 산술 연산자 사용
    - * 산술 연산자 사용 (ex. ‘8’*1)
- **불리언 타입으로**
    - Boolean 생성자 함수 사용
    - !! (부정 논리 연산자 2번 사용)

### 단축 평가
- 피연산자를 타입 변환하지 않고 그대로 반환하는 것. 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평과 과정 생략.
- **논리 연산자**
    - if문 대체 가능
    - 기본 값 설정할 때 유용함.
    - &&(논리곱 연산자)
        - 좌항에서 우항으로 평가되며 둘 다 true여야 true 반환. (첫 번째가 truthy값이면 두 번째를 반환, 첫 번째가 falsy 값이면 첫 번째를 반환.)
    - ||(논리합 연산자)
        - 좌항에서 우항으로 평가. 하나만 true여도 true 반환. (첫 번째가 truthy이면 첫 번째 반환, 첫 번째가 falsy이면 두 번째 반환.)
- **옵셔널 체이닝 연산자**
    - ?. (기호)
    - 좌항의 피연산자가 null 또는 undefined인 경우 udnefined를 반환, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
    - 단축 평가 (&&) 대신에 사용 가능하다.
- **null 병합 연산자**
    - ?? (기호)
    - 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자 반환, 그렇지 않으면 좌항의 피연산자 반환. <<좌항??우항>>
    - 단축 평가(||) 대신에 사용이 가능하며 좌항의 피연산자가 false로 평가되는 falsy값이라도 null이나 undefined가 아니면 좌항의 피연산자를 그대로 반환한다.

**ECMA: 스크립트 언어의 표준을 만들고 정보 통신에 대한 표준으로 제정한다.**
**ESn: ecma script의 줄임말로 ES14까지 나왔다.**
**script language: 기존 프로그램을 제어하는 언어로 대부분 한줄 한줄 읽어 바로 실행하는 interpreter 방식을 사용한다.**