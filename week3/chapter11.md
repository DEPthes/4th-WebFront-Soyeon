# 원시 값과 객체의 비교
### 원시 값
- 원시 타입은 (원시 값은) 변경 불가능한 값이다. **(불변성)** 변수에 실제 값이 저장된다.
- **값에 의한 전달을 한다.** - 할당받는 변수에 할당되는 변수의 원시 값이 복사되어 전달되는 것
- **변수**: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- **값**: 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과
- 변수 재할당 과정
    - 새로운 메모리 공간 확보 → 재할당한 원시 값 지정 → 변수는 재할당한 원시 값 가리킴 (메모리 공간의 주소 바뀜)
    - 재할당을 가능케 했을 때 단점: 예기치 않게 변수 값이 변경될 수 있고 상태 변경을 추척하기 어렵게 만든다. (디버깅, 값의 변경에 따른 결정 등을 어렵게 함)
- **문자열 원시 값**
    - ECMAScript에 문자열 타입(2바이트), 숫자 타입(8바이트) 외 원시 타입의 크기를 규정하지 않고 있다.
    - 문자열 1개 당 2바이트를 잡아먹는다.
    - js에서 문자열은 유사 배열 객체이다. (배열처럼 인덱스를 통해 각 문자에 접근 가능하며 length 프로퍼티를 갖고 for문으로 순회할 수 있다.)
    - 다만 일부 문자를 변경해도 반영되지 않는다.
    - 데이터의 신뢰성을 보장한다.

### 메모리 관리
- **값에 의한 전달** (사실 값이 전달되는 것이 아닌 메모리 주소를 기억하고 전달하는 거임), **참조에 의한 전달** → **공유에 의한 전달**
    - 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하나 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이이다.
- ECMAScript엔 변수를 통해 메모리를 어떻게 관리해야 하는지 명확히 정의되어 있지 않음
    - 변수에 원시 값을 갖는 변수를 할당하면 원시 값이 복사되는 방식
    - 변수는 할당하는 시점에는 같은 원시 값을 가지는 메모리 주소를 참조하다 어느 한쪽의 변수에 재할당이 이뤄졌을 때 새로운 메모리 공간에 재할당된 값이 저장되는 방식

### 객체(=변경 가능한 값)
- 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가, 삭제할 수 있다. 확보해야 할 메모리 공간의 크기를 사전해 정해둘 수 없다.
- **참조 값**: 생성된 객체가 저장된 메모리 공간의 주소
- 할당이 이뤄지는 시점에 객체 리터럴이 해석된다. (=객체 생성)
- **얕은 복사와 깊은 복사**
    - **얕은 복사**: 참조 값 복사
    - **깊은 복사**: 객체에 중첩되어 있는 객체까지 모두 복사
- **참조에 의한 전달**
    - 여러 개의 식별자가 하나의 객체를 공유할 수 있다.
    - 원본을 사본에 할당했을 때 각각의 메모리 주소는 다르지만 각 메모리는 동일한 참조 값을 가지게 된다.
    - 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.