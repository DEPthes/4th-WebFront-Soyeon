# this

### 핵심 개념
- this는 기본적으로 window가 (브라우저에서) 바인딩 된다.
- 함수 호출 방식에 따라 this가 바인딩 되는 방식이 다르다.
- strict mode로 하면 undefined가 된다.
- this.name을 브라우저에서 실행했을 경우 window엔 name 프로퍼티가 있으므로 ‘’가 나온다.

- 객체는 본인이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다. (this의 개념이 있는 이유)
- this를 사용하는 이유는 생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성하기 이전이므로 생성자 함수가 생성할 인스턴스를 가리키는 식별자를 알 수 없기에 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요하기 때문이다.
- **역할**
    - this를 통해 자신이 속학 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.
- **동작**
    - 함수 호출 시 arguments 객체와 this가 암묵적으로 함수 내부에 전달되고 그 안에서 지역변수처럼 사용할 수 있다.
- **this 바인딩:** 식별자와 값을 결정하는 과정이 바인딩인데 this가 가리킬 객체를 바인딩 하는 것 (함수가 호출되는 방식에 따라 this 바인딩이 동적으로 결정된다.)
- **strict mode와 this 바인딩**
    - 객체의 메서드 또는 내부 생성자 함수 내에서만 의미가 있기에 일반 함수 내에선 undefined가 바인딩된다.

### 함수 호출 방식과 this 바인딩
- 함수가 어떻게 호출 되었는지에 따라 동적으로 결정
- 기본적으로 this에는 전역 객체가(window) 바인딩된다.
1. **일반 함수 호출**
    - 앞서 말했지만 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자시 참조 변수이므로 객체를 생성하지 않는 일반 함수에서는 this가 의미가 없다. (window, strict mode일 때는 undefined)
    - 메서드 내부 **중첩 함수**나 **콜백 함수**의 this 바인딩을 메서드의 this 바인딩과 일치시키기 위한 방법은
    1. const that = this 처럼 값을 할당해서 사용
    2. Function.prototype.apply와 같은 메서드 사용
    3. 화살표 함수 사용
2. **메서드 호출**
    - 메서드를 호출한 객체, 마침표 연산자 앞에 기술한 객체가 바인딩된다.
3. **생성자 함수 호출**
    - 생성자 함수 내부의 this에는 생성자 함수가 미래에 생성할 인스턴스가 바인딩된다.
    - 이때 new를 사용하여 인스턴스를 사용하지 않으면 그냥 함수를 식별자에 할당한거나 마찬가지이므로 new를 꼭 써서 인스턴스를 만들어야 한다.
4. **Function.prototype.apply/call/bind**
    - apply, call, bind 메서드는 Function.prototype의 메서드이다.
    - **apply와 call**
        - 본질적인 기능은 함수를 호출하는 것이며 {함수 이름}.apply(인수) → 인수를 함수 이름에 바인딩
        - 두 개의 차이점은 두 번째 인수를 배열로 전달하느냐(apply), 따로따로 전달하느냐(call) 이다.
        - 두 번째 인수는 함수에 전달할 값이다.
    - **bind**
        - Function.prototype.bind(인수)() 이렇게 써야 한다.
        - bind는 인수로 전달한 (인수)this를 고정시킴으로써 값을 일어버리지 않게 해준다.
    - 결과적으로 일반 함수를 호출했을 때 this는 전역 객체에 바인딩
    - 메서드를 호출하면 메서드를 호출한 객체에 바인딩
    - 생성자 함수를 호출 했을 때 생성자 함수가 미래에 생성할 인스턴스를 바인딩
    - Function.prototype.~ 은 첫번째 인수로 전달한 객체에 바인딩
- **setTimeout 함수:** 두 번째 인수로 전달한 시간만큼 대기한 다음 첫 번째 인수로 전달한 콜백 함수를 호출하는 타이머 함수
    - 대기를 하는 이유는 뒤의 함수가 먼저 실행되기를 원할 때, 비동기 처리 문제 등이 있다.