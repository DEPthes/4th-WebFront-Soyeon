# 빌트인 객체

자바스크립트는 3개의 객체로 분류가 가능하다.

1. **표준 빌트인 객체**
    1. ECMAScript 사양에 정의된 객체. 자바스크립트 실행 환경과 관계없이 언제나 사용할 수 있다. 전역 객체의 프로퍼티로서 제공된다. 별도의 선언 없이 참조할 수 있다.
2. **호스트 객체**
    1. 자바스크립트 실행 환경에서 추가로 제공하는 객체이다. 클라이언트 사이드 web api를 호스트 객체로 제공하고 node.js 환경에서는 node.js 고유의 api를 호스트 객체로 제공한다.
    2. 클라이언트 사이드 web api: 브라우저에 내장되어 있는 api로 브라우저를 이용해 복잡한 작업들을 쉽게 구현할 수 있도록 도와주는 api
3. **사용자 정의 객체**
    1. 사용자가 직접 정의한 객체

### 표준 빌트인 객체
- Object, String, Number, Boolean, Symbol, Date 등 40여 개의 표준 빌트인 객체를 제공
- Math, Reflect, JSON을 제외한 표준 필트인 객체는 인스턴스를 생성할 수 있는 생성자 함수 객체다. (즉 **a**. 생성자 함수 객체인 표준 빌트인 객체와 **b.** 그렇지 않은 표준 빌트인 객체로 나눌 수 있다.)
- a는 프로토타입 메서드와 정적 메서드를 제공하고 b는 정적 메서드만 제공한다.
    - 정적 메서드: 생성자 함수로 인스턴스를 생성하지 않아도 호출할 수 있는 메소드
- a가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체이다. (String으로 생성한 인스턴스의 프로토타입은 String.prototype)

### 원시값과 래퍼 객체
- 원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없음에도 객체처럼 동작함
    - 객체처럼 마침표 표기법이나 대괄호 표기법으로 접근하면 js 엔진이 일시적으로 원시값을 연관된 객체로 변환해줌.
    - **래퍼 객체**: 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체
    - **동작 방법**: **1.** 마침표 표기법으로 접근하면 객체의 인스턴스가 생성됨. **2.** 문자열은 래퍼 객체의 [[StringData]] 내부 슬롯에 할당됨]] **3.** 래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래의 상태, 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 됨.
    - 이처럼 객체의 프로토타입 메서드와 프로퍼티를 래퍼 객체를 통해 참조할 수 있으므로 인스턴스를 생성해 사용하는 것은 권장하지 않는다.
    - null과 undefined는 래퍼 객체를 생성하지 않는다. (에러 발생)

### 전역 객체
- 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체. **최상위** 객체
- 브라우저 환경: window, Node.js 환경: global이 전역 객체를 가리킴
- **globalThis**
    - 브라우저 환경에서 Node.js 환경에서 전역 객체를 가리키던 다양한 식별자(this, window, global 등)를 통일한 식별자
- 전역 객체는 **표준 빌트인 객체**와 환경에 따른 **호스트 객체**, **var 키워드로 선언**한 전역 변수와 전역 함수를 프로퍼티로 갖는다.
- var 키워드로 선언하지 않아도 변수에 값을 할당하면 암묵적 전역이 되고 window.{식별자이름}으로 참조할 수 있다. (let, const는 개념적 블록 내에 존재)
- script 태그를 통해 코드를 분리해도 window 객체 공유함.
- 프로퍼티와 메서드를 가지고 있음
- **특징**
    - 개발자가 의도적으로 생성할 수 없다.
    - 전역 객체의 프로퍼티를 참조할 때 window는 생략 가능하다.

### 빌트인 전역 프로퍼티
- 전역 객체의 프로퍼티
- **Infinity**: 무한대를 나타내는 숫자값
- **NaN**: 숫자가 아님
- **undefined**: 정의되지 않음

### 빌트인 전역 함수
- 전역에서 호출할 수 있는 빌트인 함수
- **eval**: js 코드를 나타내는 문자열을 인수로 전달 (표현식이라면 런타임에 평가해 값을 생성) (여러 개의 문이면 다 실행한 다음 마지막 값 반환)
    - 자신이 호출된 위치에 해당하는 기존의 스코프를 런타임에 동적으로 수정 (일반 코드처럼 실행)
    - 단 **strict mode**일 경우엔 eval 함수 자체적 스코프 생성 (변수가 그 안에서만 유효)
    
    - 사용자로부터 입력받은 콘텐츠를 실행하는 것은 보안에 매우 취약하고 일반적인 코드 실행에 비해 처리 속도가 느리므로 **사용을 금해야 한다.**
- **inFinite**: 전달받은 인수가 유한수이면 true, 무한수이면 false (NaN이면 false, null은 true (숫자로 변환함)
- **isNaN**: 인수가 NaN이면 true, 아니면 false (숫자 타입으로 변환 실행)
- **parseFloat**: 문자열 인수를 실수로 해석
    - 공백으로 구분되면 첫 번째만 반환
    - 불가할 경우 NaN 반환
- parseInt: 문자열 인수를 정수로 해석
    - 두 번째 인수로는 기수를 전달할 수 있다. (default는 10진수)
    - 숫자로 선언했던 걸 기수를 지정해서 반환하고 싶을 경우에는 Number.prototype.toString 메서드를 사용해서 하면 된다.
    - 0x로 시작하는 16진수 리터럴은 16진수로 해석해서 10진수 정수로 반환 (2진수와 8진수 리터럴은 제대로 해석 못한다.)
    - 이것도 float과 마찬가지로 첫 번째 문자가 지정한 지수의 숫자로 변환될 수 없다면 NaN 반환
    - 앞뒤 공백 무시
- **encodeURI**: uri를 문자열로 전달받아 이스케이프 처리를 위해 인코딩
    - **uri**: 인터넷에 있는 자원을 나타내는 유일한 주소로 하위 개념은 url과 urn이 있다. (url은 아스키 문자 셋으로만 구성되어야 하며 한글을 포함한  대부분의 외국어, 아스키 문자 셋에 정의되지 않은 특수 문자는 포함되면 안된다.)
    - **인코딩**: uri의 문자들을 이스케이프 처리하는 것
    - **이스케이프 처리**: 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것 (- _ . ! ~ * ‘ ()는 처리되지 않는다)
- **decodeURI**: 이스케이프 처리 이전으로 디코딩한다.
- **encodeURIComponent**
    - uri의 구성 요소를 인수로 전달 받아 인코딩
    - encodeURI와 다른 점은 쿼리 스트링 구분자로 사용되는 것(= ? &)까지 인코딩 한다.
- **decodeURIComponent**: 앞과 반대

### 암묵적 전역
- 앞에서도 나왔지만 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 되기에 암묵적 전역이라고 한다.
- 전역 객체의 프로퍼티가 되어 전역 변수처럼 동작한다.
- 하지만 이는 전역 객체의 프로퍼티로 추가되었을 뿐 변수는 아니다. (선언을 안했으니 호이스팅도 안일어나겠죠)
- 프로퍼티이기에 delete 연산자로 삭제할 수 있다. (차이점)