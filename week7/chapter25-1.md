# 클래스

- 자바스크립트는 프로토타입 기반 객체지향 언어로 클래스가 필요 없는 객체지향 프로그래밍 언어이다.

### 프로토타입 기반 객체지향 모델을 폐지하고 새로운 모델 제공?
- 아니다. 그럼 문법적 설탕으로 보는 것이 적절한가? → 새로운 객체 생성 메커니즘으로 보는 것이 합당하다.

### 클래스와 생성자 함수의 차이점
1. 클래스는 new 연산자가 무조건 있어야 한다.
2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다.
3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.
4. 암묵적으로 strict mode가 지정되어 실행되며 해제 불가하다.
5. constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false다, 열거 불가하다. (for…in 등으로)

### 클래스의 정의
- class 키워드를 사용하여 정의, 파스칼 케이스 사용
- 표현식으로 정의 가능(=값으로 사용 가능)
- **특징**
    - 무명 리터럴로 생성할 수 있다. 런타임에 생성 가능하다.
    - 변수나 자료구조에 저장할 수 있다.
    - 함수의 매개변수에 전달할 수 있다.
    - 함수의 반환값으로 사용할 수 있다.
- **정의 가능한 메서드 종류**
    - constructor
        - constuctor{} 이렇게 정의
    - **프로토타입 메서드**
        - function 생략, 함수이름.prototype.메서드이름 (x)
        - 그냥 메서드 이름만 정의
    - 정적 메서드
        - static 메서드이름(){} 이렇게 정의

### 클래스 호이스팅
- 생성자 함수와의 차이점에서 호이스팅이 발생하지 않는 것처럼 보인다고 했다.
- 하지만 호이스팅이 일어난다. 단, let, const와 같이 정의 이전에 참조할 수 없다.
- (ReferenceError: Cannot access person before initialization)

### 인스턴스 생성
- class의 존재 이유는 인스턴스를 생성하는 것이기 때문에 반드시 new 연산자와 함께 호출해야 한다.
- 식별자에 class를 할당할 경우 그 class는 외부 코드에서 접근이 불가하다.

```jsx
const Person = class MyClass{}; // -> MyClass는 외부에서 접근 불가, ReferenceError, not defined 뜬다.
```

### 메서드(constructor)
- 인스턴스를 생성하고 초기화하기 위한 메서드
- 클래스도 함수이므로 함수 객체 고유의 프로퍼티를 모두 가지고 있다.
- 그 중 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor 프로퍼티는 클래스 자신을 가리키고 있는데 이는 클래스가 인스턴스를 생성하는 생성자 함수라는 것을 의미한다.
- this
    - constructor 내부 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 된다.
    
    ```jsx
    Class Person(){
    constructor(name){
    this.name = name;
    } //name은 Person의 프로퍼티가 된다.
    }
    ```
    
- constructor는 메서드가 아니라 인스턴스의 일부라고 보면 좋을 것 같다.
- **클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티**
    - 프로토타입의 constructor 프로퍼티는 모든 프로토타입이 가지고 있는 프로퍼티이며 생성자 함수를 가리키므로 둘은 관련이 없다.
- constructor는 클래스 내에 최대 한 개만 존재할 수 있고 constructor를 생략하더라도 암묵적으로 정의된다.
- 인스턴스를 초기화하려면 constructor를 생략해선 안된다.
- **반환문**
    - new 연산자와 함께 class가 호출되면 생성자 함수와 동일하게 암묵적으로 this, 인스턴스를 반환하는데 return문을 사용하여 다른 객체를 반환하면 인스턴스가 반환되지 못하므로 반환문을 갖지 말아야 한다. (기본 동작 훼손)
    - 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.

### 메서드(프로토타입 메서드)
- 클래스 몸체에서 정의한 메서드는 생성자 함수에 의한 객체 생성 방식과 다르게 클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.
- → 클래스는 생성자 함수와 마찬가지로 프로토타입 기반 객체 생성 메커니즘이다.

### 메서드(정적 메서드)
- 인스턴스를 생성하지 않아도 호출할 수 있는 메서드 (Person.say)
- static 메서드이름(){} 처럼 쓴다.
- 클래스에 바인딩된 메서드가 된다. 클래스는 함수 객체로 평가되므로 자신의 프로퍼티, 메서드를 소유할 수 있다.
- 해당 메서드는 인스턴스로 호출할 수 없다. 정적 메서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인 상에 존재하지 않기 때문이다. (예를 들어 Person이면 Person에 직접 있고 Person.prototype에 없어서)
- this는 인스턴스가 아닌 클래스를 가리킨다.
- this를 사용하지 않는 메서드는 정적 메서드로 정의하는 것이 좋다.

### 정적 메서드와 프로토타입 메서드의 차이
1. 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

### 유틸리티 함수
- Math, Number, Json 등 클래스 또는 생성자 함수를 하나의 네임스페이스로 사용해 정적 메서드를 모아 놓으면 이름 충돌 가능성을 줄여주고 관련 함수들을 구조화할 수 있는 효과가 있다.

### 클래스의 인스턴스 생성 과정
1. 인스턴스 생성과 this 바인딩
    1. new 연산자와 함께 class를 생성하면 빈 객체가 생성(=인스턴스)
    2. 인스턴스의 프로토타입으로 클래스의 proototype 프로퍼티가 가리키는 객체가 설정된다. (인스턴스 person은 Person.prototype을 상속하므로 Person의 메서드를 사용할 수 있다.)
2. 인스턴스 초기화
    1. this에 바인딩되어있는 인스턴스에 프로퍼티를 추가하고 전달받은 초기값으로 인스턴스의 프로퍼티 값 초기화 (constructor가 정의되어 있을 때)
3. 인스턴스 반환
    1. 바인딩된 this의 반환