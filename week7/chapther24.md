# 클로저

MDN 에서의 클로저 정의: “함수와 그 함수가 선언된 렉시컬 환경과의 조합” (→ 즉 중첩함수에서 중첩된 함수와 외부 함수의 렉시컬 환경과의 조합)

- 렉시컬 스코프(정적 스코프) 재정리: 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정하는 것

### 함수 객체 내부 슬롯 [[Environment]]
- (슬롯이란 재사용성을 높여주는 기능이다.)
- 함수는 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 상위 스코프의 참조를 저장한다.
- 함수가 평가되어 함수 객체를 생성하는 시점(런타임 전)에 자신이 정의된 환경에 의해 결정된 상위 스코프의 참조를 함수 객체 내부 슬롯 [[Environment]]에 저장한다.

### 클로저와 렉시컬 환경
**클로저**
- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있는 것
- 함수를 어디서 호출하든 상관 없이 (함수 객체를 생성하는 시점에 상위 스코프를 저장하기 때문에 ) 언제나 자신이 기억하는 상위 스코프의 식별자를 참조할 수 있다.
- 외부 함수가 실행 컨텍스트에서 없어지더라도 중첩 함수가 외부 함수를 참조하고 있으니 렉시컬 환경은 소멸되지 않는다.
- (=가비지 컬렉션의 대상이 아니다.)
- js의 모든 함수는 상위 스코프를 기억하므로 이론적으로는 모든 함수가 클로저이지만 그건 아니다. (**클로저가 되기 위한 조건이 있다.**)
    - 상위 스코프의 어떤 식별자도 참조하지 않으면 클로저라고 하지 않는다. (최적화를 통해 상위 스코프를 기억할 일이 없으니 기억하지 않기 때문이다. 메모리 낭비 x)
    - 외부함수보다 중첩함수가 일찍 소멸되면 중첩 함수는 클로저라고 하지 않는다.
- **js의 최적화**
    - 상위 스코프의 식별자 중에서 클로저가 참조하고 있는 식별자만 기억한다. (식별자가 여러 개일 경우)
    - 클로저에 의해 참조되는 상위 스코프의 변수를 **자유 변수**라고 부른다.

### 클로저의 활용
- **사용 이유**
    - 상태를 안전하기 변경하고 유지하기 위해 (=상태를 안전하게 은닉, 특정 함수에게만 상태 변경 허용) → **실행 컨텍스트에선 내려가있고, 클로저에만 저장되어 있기 때문**
    
    ```jsx
    const increase = (function(){ //즉시 실행 함수라 한 번만 실행되므로 num이 초기화되지 x
    	let num = 0;
    	return function(){ //여기는 클로저이므로 num 값을 계속 기억하고 있다.
    		return ++num;
    	};
    }());
    console.log(increase()); 
    console.log(increase());
    
    ```
    
    - 외부 상태 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에서 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이기 위해 사용
- 함수 이름.prototype.메서드이름 → 이렇게 프로토타입을 통해 상속되는 프로토타입의 메서드라도 상위 변수를 참조할 수 있다.

```jsx
function makeCounter(predicate){
	let counter = 0;
	return function (){
		counter = predicate(counter);
		return counter;
	};
}
const in = new makeCounter(함수); //인스턴스 두개는 makeCounter의 function을 return하는건 똑같지만 다른 독립된 렉시컬 환경을 갖는다.
const out = new makeCounter(함수);
```

### 캡슐화와 정보 은닉
- **캡슐화**: 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것
- **정보 은닉:** 캡슐화가 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하는 것
    - 외부에 공개할 필요 없는 것을 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는 것 방지해 정보를 보호하고, 객체의 결합도를 낮추는 효과가 있다.
    - 캡슐화와 결합도는 반대로 이뤄진다.
- js 객체의 모든 프로퍼티와 메서드는 기본적으로 외부에 공개되어있다. (public)
- 지역변수는 private하다.
- 함수 안에 프로토타입 메서드를 지정하면 이 메서드는 한 번만 생성되는 클로저이기에 정보를 보호할 수 없다. (메모리 낭비는 줄지만 정보 은닉도 되지 않는다.)

→ 자바스크립트는 정보 은닉을 완전하게 지원하지 않는다.

```jsx
var funcs = [];
for(var i = 0; i<3; i++){
funcs[i] = functions(){return i;};
//var는 함수 레벨 스코프이므로 끝날 때 3으로 저장된다.
//해당 코드는 저장이 아닌 functions(){return i;}를 참조 한다는 것을 기억해야 한다.
//해결방법
//1. 즉시 실행 함수 사용
//2. let을 사용하여 새로운 렉시컬 환경 생성
}
for(var j = 0; j<funcs.length; j++){
console.log(funcs[j]());
}
```